# Вопросы к собеседованию от JR:

## Java Multithreading. 1 уровень.

- Перечислите методы класса Object
> toString(), hashCode(), equals(), getClass(), notify, notifyAll(), wait(), finalize(), clone()
- Зачем нужны методы equals & hashCode? 
> сравнение и быстрое сравнение
- Что будет, если переопределить equals, но не переопределить hashCode? 
> в случае коллизии до equals может не дойти и разные obj окажутся ==
- Зачем нужны методы wait, notify, notifyAll? 
> освободить mutex vs разбудить 1 поток vs разбить все потоки
- Как правильно клонировать объект? 
> реализовать свой clone() (можно например сделать deep-clone через сериализацию)
- Зачем нужен метод finalize() и как он работает? 
> finalize() можно использовать только в двух случаях:  
1 Проверка/подчистка ресурсов с логированием  
2 При работе с нативным кодом, который не критичен к утечке ресурсов  
finalize() замедляет работу GC по очистке объекта в 430 раз  
finalize() может быть не вызван  
- В чем отличие final, finally, finalize? 
> final(Class, parameter, var) vs finally-block vs destructor==finalize()
- Что такое try-with-resources? 
> аналог try-catch-finally с авто вызовом close интерфейса AutoCloseable
- Чем отличаются методы wait(1000) и sleep(1000)? 
> отдать mutex vs подождать
- В чем отличие i++ и ++i ? 
> взять значеие и увеличить vs увеличить и взять значение

## Java Multithreading. 2 уровень.

- Как правильно сравнить две строки в Java? 
> equals 
- Как правильно сравнить две строки в Java игнорируя регистр букв? 
> equalsIgnoreCase
- Как отсортировать список строк в алфавитном порядке? 
> Collections.sort(arr)
- В какой кодировке хранятся строки в Java? 
> Unicode
- Как преобразовать строку в кодировку Windows-1251? 
> new String(s.getBytes(), Charset.forName("Windows-1251"));
- Как разбить строку на отдельные слова? 
> split, StringTokenizer
- Как развернуть строку задом наперед? 
> StringBuilder.reverse(), StringBuffer.reverse()
- Что происходит, когда мы пишем «A»+«b»+«C»? 
> StringBuilder или StringBuffer (на усмотрение компилятора), метод append
- Что такое mutable и immutable типы?
> изменяемые и readonly
- Что дает типу String то, что его сделали immutable? 
> использовать в многопоточном приложении без sync (thread-safe)

## Java Multithreading. 3 уровень.

- Какие бывают внутренние классы? 
> внутренние классы в локальном методе, анонимные классы, нестатические вложенные классы.
- Во что компилируется анонимный внутренний класс? 
> Компилятор создает внутренние классы (non-static) для всех анонимных внутренних классов. 1,2,3
- Зачем использовать ключевое слово final при создании анонимных классов?
> Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование
- Как правильно создать объект внутреннего класса?
> Outer outer = new Outer(); Innter inner = outer.new Inner(); 
- Как правильно создать объект вложенного класса?
> OuterClass.StaticNestedClass staticNestedClass = new OuterClass.StaticNestedClass();
- Можно ли создавать статические методы/переменные во внутреннем классе? 
> нет
- Назовите три любых внутренних класса? 
> java.util.HashMap.Holder, java.util.HashMap.Entry<K, V>, IntegerCache в Integer
- Как внутренние классы решают проблему множественного наследования в Java? 
> Т.к. множественное наследование классов в Java запрещено, эту проблему решают с помощью внутренних классов: в нужном нам классе мы объявляем внутренний класс и наследуем его от требуемого класса.
- Чем отличаются анонимные классы, созданные на основе интерфейса и на основе класса? 
> Инициализации анонимного класса на основе интерфейса потребует реализации каждого метода, в то время как при инициализации анонимного класса на основе абстрактного/конкретного класса позволит изменить поведение за счет перегрузки методов и потребует реализации абстракных методов.
- Можно ли создать анонимный статический вложенный класс? 
> Нет, статической становится только переменная, но не класс.

## Java Multithreading. 4 уровень.

- Во что компилируются анонимные внутренние классы? 
> внешнийКласс$n.class
- Можно ли наследовать внутренние классы? 
> да + конструктор с ссылкой на внешний класс
- Можно ли наследовать анонимные внутренние классы? 
> Описывая анонимный класс мы уже наследуемся от какого-то класса или реализуем какой-либо интерфейс
- Можно ли переопределять внутренние классы? 
> нельзя. при наследовании от внешнего класса ничего особенного с внутренними классами не происходит. Два внутренних класса — совершенно отдельные составляющие, с независимыми пространствами имен.
- Какие ограничения есть у локальных классов? 
- Может ли анонимный внутренний класс содержать статические методы? 
> Нет
- Можно ли создать объект внутреннего класса, если у внешнего класса только private конструктор? 
> можно, если каким-либо способом нам удастся получить объект обрамляющего класса. Например getInstance()
- Можно ли объявлять внутренние классы private? 
>Да
- Можно ли объявлять анонимные внутренние классы private?  
> Можно объявить private переменную от типа которой наследуется наш анонимный класс
- Сколько у класса максимально может быть внутренних классов? 
> Сколь угодно много.

## Java Multithreading. 5 уровень.

- Назовите все состояния объекта Thread? 
> NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED
- В какие состояния может перейти нить, при входе в блок synchronized? 
> RUNNABLE BLOCKED
- В какое состояние перейдет нить, при вызове метода wait()? 
> WAITING BLOCKED
- В какое состояние перейдет нить, при вызове метода wait(500)? 
> TIMED_WAITING BLOCKED
- В какое состояние перейдет нить, при вызове метода notify()? 
> RUNNABLE BLOCKED
- В какое состояние перейдет нить, при вызове метода notifyAll()? 
> RUNNABLE BLOCKED
- Три нити в блоке synchronized вызвали wait() у объекта-мютекса. В какое состояние перейдут эти нити, если четвертая нить вызовет notifyAll()? 
> Две из них перейдут в состояние BLOCKED, одна в состояние RUNNABLE
- Чем отличается join(500) от wait(500)?
- Чем отличается wait(500) от sleep(500)?
- В какое состояние перейдет нить при вызове метода yield()? 
> При вызове метода yield() – текущая нить «пропускает свой ход» и java сразу переключается на выполнение следующей нити. Нить из состояния running переходит в состояние ready. Состояния running & ready – это подсостояния состояния RUNNABLE.

## Java Multithreading. 6 уровень.

-	Как пользоваться интерфейсом Comparable? 
> compareTo(Object obj) 0, если значения равны; >0, если вызываемый объект > параметра; -1, если меньше
-	Как пользоваться интерфейсом Comparator? 
> compare(Object obj1, Object obj2), equals(Object obj); Этот метод служит для сравнения самих экземпляров интерфейса Comparator и должен возвращать true только в том случае, если сравниваемые объекты обеспечивают одинаковый порядок сортировки.
-	Какие методы есть у класса Collections? 
> addAll, binarySearch, sort, shuffle, rotate, reverse, nCopies, replaceAll, frequency, fill, emptySet, emptyList, emptyMap, disjoint, min, max, copy, etc... 
-	Какие методы есть у класса Arrays? 
> asList, binarySearch, fill, copyOf, sort, copyOfRange, 
-	Как называется сортировка, которая используется при вызове Collections.sort()? 
> TimSort
-	Что такое канкаренси? 
> параллели́зм — это свойство систем, при котором несколько вычислений выполняются одновременно, и при этом, возможно, взаимодействуют друг с другом. java.util.concurrent: Concurrent Collections, Queues, Synchronizers, Executors, Locks, Atomics
-	Какие классы из «канкаренси» ты знаешь? 
> ConcurrentHashMap, Atomic*, 
-	Как устроен класс ConcurrentHashMap?
-	Что такое класс Lock? 
> java.util.concurrent.locks, Lock - interface, ReentrantLock
-	Что такое итератор? 
> обеспечивает итерацию контейнерных классов. Каждый Iterator реализует методы next() и hasNext() и дополнительно может поддерживать метод remove().
-	Что такое mutex? 
> Мютекс – это специальный объект для синхронизации нитей/процессов. Он может принимать два состояния – занят и свободен.
-	Что такое монитор? 
> Монитор – это специальный механизм (кусок кода) – надстройка над мютексом, который обеспечивает правильную работу с ним. В Java монитор реализован с помощью ключевого слова synchronized

## Java Multithreading. 7 уровень.

-	Что такое дедлок? 
> (взаимная блокировка) ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать свое выполнение.
-	Какие вы знаете стратегии, предотвращающие появление дедлоков? 
> установить порядок блокиорвки/освобождения ресурсов (требует id)
-	Могут ли возникнуть дедлоки при использовании методов wait-notify? 
> да, могут. Условно «первая» нить может ждать, пока её не выведет из этого состояния «вторая» нить, которая в свою очередь ждёт пока её не выведет из состояния ожидания первая нить: ждут друг друга. Задача об обедающих философах, предложенная Эдгаром Дейкстрой — как раз по своей сути является освещением проблемы возникновения взаимной блокировки в контексте использования wait/notify 
-	Что чаще используется: notify или notifyAll?
-	Метод wait рекомендуется использовать с конструкциями if или while? 
> если поток ждет выполнения некоторого условия – вариант с while надежнее. Если поток пустили по ошибке – он опять проверит условие и, если надо, будет ждать дальше.
-	Что происходит после вызова метода notifyAll? 
> wakes up all threads that are waiting on this object's monitor. A thread waits on an object's monitor by calling one of the wait methods.
-	Какие выгоды получает объект, если он immutable? 
> thread-safe
-	Что такое «thread-safe»? 
> Thread safe means that a method or class instance can be used by multiple threads at the same time without any problems occuring
-	Что такое «happens-before»? 
> механизм синхронизации локальной памяти нитей. Если указывается, что запись в переменную и последующее ее чтение связаны через эту зависимость, то как бы при выполнении не переупорядочивались инструкции, в момент чтения все связанные с процессом записи результаты уже зафиксированы и видны.
-	Что такое JMM? 
> The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.;  это организация взаимодействия потоков через общую память, допустимые в языке пути исполнения инструкций.
-	Какое исключение вылетит, если вызвать wait не в блоке synchronized?
> IllegalMonitorStateException, чтобы избежать состояния гонки между вызовами wait и notify.

## Java Multithreading. 8 уровень.

-	Какие приоритеты нитей бывают? 
> 1..10 default=5
-	Можно ли остановить нить, снизив ее приоритет до 0? 
> нет, IllegalArgumentException, что бы остановить нить вызываем Thread.interrupt(); правда не факт что остановит. нити-демоны остановятся при остановке главного потока.
-	Зачем нужен класс ThreadGroup? 
> Нить может оказывать влияние только на другие нити, которые содержатся в той же группе, что и она. ThreadGroup – это класс, который управляет группами нитей. Такой подход позволяет защитить нити от нежелательного изменения. Иногда приходится выполнять код, которому нельзя 100% доверять. Поэтому удобно поместить все его нити в отдельную группу и запретить им вмешиваться в работу основной группы нитей.
-	В какой группе нитей состоит main-thread? 
> main
-	Что такое паттерн ThreadPool? 
> группа потоков, которые решают задачи. Задачи организованы в очередь. Как только поток завершает работу над задачей, он запрашивает следующую задачу из очереди, до тех пор, пока все задачи в очереди не будут выполнены. После этого поток может завершиться, либо уснуть, до тех пор, пока в очереди не появятся новые задачи. 
-	Зачем нужен класс ThreadPoolExecutor? 
> Чтобы начать выполнять новое задание, как только оно появится.Это класс, который имеет внутри: Очередь задач, в которую можно добавлять задачи, по мере их появления в программе и пул-нитей (группа нитей) – которые эти задачи исполняют. При этом нити не уничтожаются после выполнения задания, а засыпают.
-	Сколько способов создать нить вы знаете? 
> (Thread, Runnable, Callable<T>)
-	Для чего используется класс Future? 
> Этот объект можно использовать, чтобы узнать, завершилось ли уже выполнение задачи, а также, чтобы получить результат ее выполнения. cancel, isCanceled, isDone(), get() throws InterruptedException, ExecutionException;
-	В чем преимущества Callable над Runnable? 
> Используя Callable мы можем узнать завершилась ли задача, и узнать её результат, гораздо проще, чем при использовании Runnable
-	Можно ли отменить выполнение задачи, если использовать класс Future? 
> Можно, если задача лежит в очереди и ожидает своего исполнения, иначе не факт

## Java Multithreading. 9 уровень.

- Что такое autoboxing?  
> это механизм неявной инициализации объектов классов-оберток (Byte, Short, Character, Integer, Long, Float, Double) значениями соответствующих им исходных примитивных типов (соотв. byte, short, char, int, long, float, double), без явного использования конструктора класса.
- Зачем используется autoboxing? 
> Например коллекции и generic’и могут работать только с типами, унаследованными от Object.
- Альтернативы autoboxing? 
> примитивы, использовать autoboxing только там где это необходимо, т.к. снижается производительность.
- Типы-обертки для примитивных типов mutable или immutable? 
> Immutable, так как примитивные объекты тоже immutable. Чтобы работать как с Mutable типом есть класс MutableInteger.
- Как примитивные типы приводятся к непримитивным аналогам? 
> Компилятор использует метод valueOf() чтобы преобразовать примитивные типы в объекты, а методы IntValue(), doubleValue() и т.д., чтобы получить примитивные типы из объекта (то есть обратное преобразование).
- Как непримитивные типы приводятся к примитивным? 
> методы IntValue(), doubleValue() и т.д.
- Как сравниваются примитивные и непримитивные типы? 
> == используется для примитивных типов. Для объектов «==» это исключительно сравнение ссылок. Для остальных случаев нужно использовать метод equals(). не забываем про hashCode()
- Всегда ли создается новый объект при операции autoboxing? 
> Если мы пишем new Integer(), то гарантированно создается новый объект. Если мы вызываем Integer.valueOf(), явно или при autoboxing, то этот метод может вернуть для нас как новый объект, так и отдать объект из кэша, если переданное число лежит в диапазоне от -128 до 127.
- Как работает кэширование при операции autoboxing? см. выше
- Для каких типов и/или значений работает кэширование? см. выше

## Java Multithreading. 10 уровень.

- Что такое NaN? 
> NaN (англ. Not-a-Number) — одно из особых состояний числа с плавающей запятой. Используется во многих математических библиотеках и математических сопроцессорах. Данное состояние может возникнуть в различных случаях, например, когда предыдущая математическая операция завершилась с неопределённым результатом.
все математические операции, содержащие NaN в качестве одного из операндов;
деление нуля на нуль;
деление бесконечности на бесконечность;
умножение нуля на бесконечность;
сложение бесконечности с бесконечностью противоположного знака;
вычисление квадратного корня отрицательного числа[1];
логарифмирование отрицательного числа.
NaN не равен ни одному другому значению (даже самому себе[2]); соответственно, самый простой метод проверки результата на NaN — это сравнение полученной величины с самой собой.

- Как получить бесконечность в Java? 
> В Java тип double имеет специальные значения для понятий «плюс бесконечность» и «минус бесконечность». Положительное число, разделенное на 0.0, дает «плюс бесконечность», а отрицательное – «минус бесконечность». Этим понятиям соответствуют специальные константы типа Double: POSITIVE_INFINITY, NEGATIVE_INFINITY
- Как проверить, что в результате вычисления получилась бесконечность? 
> java.lang.Double.isInfinite() 
- Что такое битовая маска? 
> Битовая маска — это когда хранится много различных логических значений (true/false) в виде одного целого числа. При этом каждому boolean-значению соответствует определенный бит.
- Где применяют битовые маски? 
> В основном там, где надо компактно хранить много информации об объектах.
- Как установить бит в единицу в битовой маске? 
>
- Как установить бит в ноль в битовой маске?
>
- Как получить значение определенного бита в битовой маске?
> 
- Что такое ленивое вычисление выражения? 
> Это ленивые вычисления (lazy evaluation). В ленивых вычислениях ни один параметр не вычисляется, пока в нем нет необходимости.
- Чем отличается использование && и & для типа boolean? 
> && — это логическое «и». (В этом случае имеют место ленивые вычисления: некоторые вычисления опускаются, когда результат и так ясен). & — это побитовое «и» (Если применить этот оператор к переменным типа Boolean, то ленивых вычислений происходить не будет)

Дополнительно:
- livelock -  система не «застревает» (как в обычной взаимной блокировке), а занимается бесполезной работой, её состояние постоянно меняется — но, тем не менее, она «зациклилась», не производит никакой полезной работы
- Обнаружение взаимных блокировок. Поиск взаимных блокировок осуществляется путём построения и анализа графа ожидания. В графе ожидания узлами отмечаются процессы и объекты. Блокировки отмечаются рёбрами, направленными от узла, соответствующего захваченному объекту, к узлу, соответствующему захватившему его процессу. Ожидания отмечаются рёбрами, направленными от узла, соответствующего ожидающему процессу, к узлу, соответствующему ожидаемому объекту. Цикл в графе ожидания соответствует взаимной блокировке.
- В случае, если ваше приложение очень часто использует целые типы, можно увеличить кеш для Integer через системное свойство «java.lang.Integer.IntegerCache.high», а так же через параметр виртуальной машины -XX:AutoBoxCacheMax=<size>.